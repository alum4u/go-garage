@startuml go-garage

package base {
    class base.StatsStorage {
        -readyCheck: MapCheckFunc
        -aliveCheck: MapCheckFunc
        -metrics: MapMetricsOptions
        -metricsMutex: sync.RWMutex
        +GetAliveHandlers(ctx context.Context) MapCheckFunc
        +GetMetrics(ctx context.Context) MapMetricsOptions 
        +GetReadyHandlers(ctx context.Context) MapCheckFunc
    }

    class base.Enity {
        *StatsStorage
        ---
        -name: string
        -providerName: string
        -shuttingDown: bool
        -watcherStopped: bool
        ---
        +GetName(): string
        +GetFullName(): string
        +IsShuttingDown(): bool
        +SetShuttingDown(v bool)
        +IsWatcherStopped(): bool
        +SetWatcherStopped(v bool)
        +GetLogger(ctx context.Context): *zerolog.Logger
    }

    base.Enity *-- base.StatsStorage
}

package app {
    interface app.EnityGateway {
        +Shutdown(ctx context.Context): error
        +Start(ctx context.Context): error
        +GetMetrics(ctx context.Context): (MapMetricsOptions, error)
        +GetAliveHandlers(ctx context.Context): (MapCheckFunc, error)
        +GetReadyHandlers(ctx context.Context): (MapCheckFunc, error)
    }

    class app.Manager {
        *base.StatsStorage
        ---
        -entitys: sync.Map
        -errAnswer(ctx context.Context, w http.ResponseWriter, msg, code string)
        -readyCheckHandler(w http.ResponseWriter, r *http.Request)
        -aliveCheckHandler(w http.ResponseWriter, r *http.Request)
        -prometheusMiddleware(handler http.Handler) http.Handler
	    -statsHTTPEnityName: string
        +Add(ctx context.Context, enityName string, enity EnityGateway): error
        +Get(ctx context.Context, enityName string): (EnityGateway, error)
        +Range(ctx context.Context, f func(k, v interface{}) bool) error
        +Shutdown(ctx context.Context): error
        +Start(ctx context.Context): error
        +Loop(ctx context.Context): error
    }
}

package enities {
    package redis {
        class redis.Mutex {
            -conn: *rejson.Client
            -lockKey: string
            -lockValue: string
            -checkInterval: time.Duration
            -expire: time.Duration
            -locked: bool
            -mu: sync.RWMutex
            -commonLock(ctx context.Context): (err error)
            -commonUnlock(ctx context.Context): (err error)
            -commonExtend(ctx context.Context, timeout time.Duration): (err error)
            +Lock(ctx context.Context): (err error)
            +Unlock(ctx context.Context): (err error)
            +Extend(ctx context.Context, timeout time.Duration): (err error)
        }

        class redis.Config {
            +DSN: string
            +MaxConnectionLifetime: time.Duration
            +MinIdleConnections: int
            +MaxOpenedConnections: int
            +StartWatcher: bool
            +Timeout: time.Duration
            +KeyPrefix: string
            +ClearTime: time.Duration
            +SetDefault(): *Config
            +GetOptions(): (*redis.Options, error)
        }

        class redis.Enity {
            *base.Entity
            ---
            -conn: *rejson.Client
            -config: *Config
            -startWatcher(ctx context.Context)
            ---
            -shutdown(ctx context.Context) error
            -watcher(ctx context.Context) bool
            +Ping(ctx context.Context) error
            +GetConn(): *rejson.Client
            +GetConfig(): *Config
            +Shutdown(ctx context.Context) error
            +Start(ctx context.Context) error
            +SetConnPoolLifetime(connMaxLifetime time.Duration)
            +SetConnPoolLimits(minIdleConnections, maxOpenedConnections int)
            +WaitForEstablishing(ctx context.Context)
            +Get(ctx context.Context, key string, value interface{}): error
            +JSONGet(ctx context.Context, key, path string, value interface{})
            +Set(ctx context.Context, key string, value interface{}): error
            +SetNX(ctx context.Context, key string, value interface{}): error
            +JSONSet(ctx context.Context, key, path, json string): error
            +JSONSetNX(ctx context.Context, key, path, json string): error
            +Delete(ctx context.Context, key string): error
            +Size(ctx context.Context): (int, error)
            +GetMetrics(ctx context.Context): (base.MapMetricsOptions, error)
            +GetReadyHandlers(ctx context.Context): (base.MapCheckFunc, error)
            ---Mutex---
            +NewMutex(expire, checkInterval time.Duration): (*Mutex, error)
            +NewMutexByID(lockID string, expire, checkInterval time.Duration): (*Mutex, error)
        }

        redis.Enity *-- base.Enity
    }

    package pq {
        class pq.Config {
            +DSN: string
            +MaxConnectionLifetime: time.Duration
            +MaxIdleConnections: int
            +MaxOpenedConnections: int
            +Options: string
            +QueueWorkerTimeout: time.Duration
            +StartQueueWorker: bool
            +StartWatcher: bool
            +Timeout: time.Duration
            +Migrate: *migrations.Config
            +SetDefault() *Config
            +ComposeDSN() string
            +GetDBName() string
        }

        class pq.Enity {
            *base.Entity
            ---
            -conn: *sqlx.DB
            -config:  *Config
            -queue: *sql.Queue
            -queueWorkerStopped: bool
            ---
            -startWatcher(ctx context.Context): error
            -shutdown(ctx context.Context): error
            +Ping(ctx context.Context): error
            +Shutdown(ctx context.Context): error
            +Start(ctx context.Context, errorGroup *errgroup.Group) error
            +SetConnPoolLifetime(connMaxLifetime time.Duration)
            +SetConnPoolLimits(maxIdleConnections, maxOpenedConnections int)
            +SetPoolLimits(maxIdleConnections, maxOpenedConnections int, connMaxLifetime time.Duration)
            +GetMetrics(ctx context.Context): (base.MapMetricsOptions, error)
            +GetReadyHandlers(ctx context.Context): (base.MapCheckFunc, error)
            ---Mutex---
            +NewMutex(checkInterval time.Duration): (*Mutex, error)
            +NewMutexByID(lockID int64, checkInterval time.Duration): (*Mutex, error)
            ---Queue---
            -startQueueWorker(ctx context.Context): error
            +AppendToQueue(queueItem *sql.QueueItem)
        }

        pq.Enity *-- base.Enity
    }

    package migrations {
        class migrations.Config {
            +Action: string
            +Count: int64
            +Directory: string
            +Only: bool
            +MigrationsType: Type
            +Schema: string
            +SetDefault() *Config
        }

        class migrations.Migrator {
            -db: *sql.DB
            -config: *Config
            -migratedMutex: sync.Mutex
            -migrated: bool
            -name: string
            -dialect: string
            -setMigrationFlag()
            -waitConn(ctx context.Context): error
            -getCurrentDBVersion(ctx context.Context) int64
            -migrate(ctx context.Context, currentDBVersion int64) error
            -migrateSchema(ctx context.Context) error
            +Migrate(ctx context.Context)
            +SetSchema(schema string)
        }

        class migrations.InCode {
            +Name: string
            +Down func(tx *sql.Tx) error
            +Up func(tx *sql.Tx) error
        }

        class migrations.Global {
            +NewMigrator(ctx context.Context, name, dialect string, conn *sql.DB, cfg *Config) *Migrator
            +RegisterMigration(migration *InCode)
        }
    }

    package mongo {
        class mongo.Config {
            +DSN: string
            +Options: string
            +StartWatcher: bool
            +Timeout: time.Duration
            +SetDefault() *Config
            +GetDBName() string
            +ComposeDSN() string
        }

        class mongo.Enity {
            *base.Entity
            ---
            -conn: *mongo.Client
            -config: *Config
            -dbName: string
            -bucket: *gridfs.Bucket
            ---
            -startWatcher(ctx context.Context): error
            -shutdown(ctx context.Context): error
            +GetConn(ctx context.Context): *mongo.Client
            +GetConfig(ctx context.Context): *Config
            +Ping(ctx context.Context): error
            +Shutdown(ctx context.Context): error
            +Start(ctx context.Context, errorGroup *errgroup.Group) error
            +GetMetrics(ctx context.Context): (base.MapMetricsOptions, error)
            +GetReadyHandlers(ctx context.Context): (base.MapCheckFunc, error)
            ---Bucket---
            -newBucket(): (*gridfs.Bucket, error)
            -writeToGridFile(ctx context.Context, fileName string, file multipart.File, gridFile *gridfs.UploadStream): (int, error)
            +WriteMultipart(ctx context.Context, fileprefix string, multipartForm *multipart.Form): (ObjectIDFileName, error)
            +GetFile(ctx context.Context, fileID string): (*bytes.Buffer, int64, error)
            +GetFileByName(ctx context.Context, fileName, fileprefix string): (*bytes.Buffer, int64, error)
            +DeleteFile(fileID string): error
            +RenameFile(fileID, newFilename string): error
            +UpdateFile(ctx context.Context, fileID, fileprefix string, multipartForm *multipart.Form): error
        }

        mongo.Enity *-- base.Enity
    }

    package echo {
        class echo.Config {
            +Address: string
            +DisableHTTP2: bool
            +Debug: bool
            +HideBanner: bool
            +HidePort: bool
            +CertFile: string
            +KeyFile: string
            +BodyReadTimeout: time.Duration
            +BodyWriteTimeout: time.Duration
            +HeaderReadTimeout: time.Duration
            +Middlewares: []interface{}
            +SetDefault(): *Config
            +NewEcho(): *echo.Echo
        }

        class echo.Enity {
            *base.Entity
            ---
            -server *echo.Echo
            -apiGroups sync.Map
            -serverStart      bool
            -serverStartMutex sync.RWMutex
            -serverStarted      bool
            -serverStartedMutex sync.RWMutex
            ---
            +GetServer(ctx context.Context): *echo.Echo
            +GetConfig(ctx context.Context): *Config
            +Start(ctx context.Context): error
            +Shutdown(): error
            +RegisterEndpoint(method, endpoint string, handler http.Handler, m ...MiddleWareFunc): error
            +BuildSwagger(ctx context.Context)
            ---API Group---
            +GetAPIVersionGroup(apiVersion string): (*Group, error)
            +CreateAPIVersionGroup(ctx context.Context, apiVersion string, middlewares ...interface{}): error
        }

        echo.Enity *-- base.Enity
    }
}


@enduml